<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Plugin interfaces reference &mdash; CKAN 2.2.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/css/bootstrap.css" type="text/css" />
    <link rel="stylesheet" href="../_static/css/fix.css" type="text/css" />
    <link rel="stylesheet" href="../_static/css/bootstrap-responsive.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="https://media.readthedocs.org/css/badge_only.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-2.0.3.min.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-migrate-1.2.1.min.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/underscore.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/doctools.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/readthedocs-doc-embed.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-css-tweaks.js"></script>
    <link rel="top" title="CKAN 2.2.3 documentation" href="../index.html" />
    <link rel="up" title="Writing CKAN extensions" href="index.html" />
    <link rel="next" title="Plugins toolkit reference" href="plugins-toolkit.html" />
    <link rel="prev" title="Best practices for writing extensions" href="best-practices.html" />

  
<!-- RTD Extra Head -->

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://docs.ckan.org/en/latest/extensions/plugin-interfaces.html" />

<link rel="stylesheet" href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />

<script type="text/javascript" src="../_static/readthedocs-data.js"></script>

<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = 'extensions/plugin-interfaces'
</script>

<script type="text/javascript" src="../_static/readthedocs-dynamic-include.js"></script>

<!-- end RTD <extrahead> --></head>
  <body>
  
  <div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container-fluid">
        
        <a class="logo-icon pull-left" href="../contents.html"><img src="../_static/ckanlogo.png" alt="CKAN" /></a>
        
        <a class="brand" href="../contents.html">CKAN<span class="version"> v2.2.3</span></a>
        
        
        <a class="okfn-logo pull-right" href="http://okfn.org/" title="An Open Knowledge Foundation Project">
          <img src="https://s3.amazonaws.com/assets.okfn.org/p/okfn/img/logo_28x30.png" alt="Open Knowledge Foundation logo" />
        </a>
        
        
          
<form class="pull-right navbar-search" action="http://docs.ckan.org/en/ckan-2.2.3/search.html" method="get">
  <input type="text" name="q" placeholder="Search" class="search-query span2" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        
      </div>
    </div>
  </div>

<div class="container-fluid">
  <div class="row-fluid">
    <div class="span4">
      <div class="well sidebar-nav">
        
          
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><div class="widget toc">
  <h3>Table of Contents</h3>
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to CKAN&#8217;s Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-guide.html">User guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sysadmin-guide.html">Sysadmin guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installing.html">Installing CKAN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../upgrading.html">Upgrading CKAN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../features.html">Features</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Writing CKAN extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tutorial.html">Writing extensions tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="testing-extensions.html">Testing extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="best-practices.html">Best practices for writing extensions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="plugin-interfaces.html">Plugin interfaces reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="plugins-toolkit.html">Plugins toolkit reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="converters.html">Converter functions reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="validators.html">Validator functions reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../theming.html">Theming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">The CKAN API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing to CKAN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test.html">Testing CKAN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration.html">Config File Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendices/index.html">Appendices</a></li>
</ul>

</div>

        </div>
      </div>
        
      </div><!--/.well -->
    </div><!--/span-->
    <div class="span8">
      <div class="content">

        
        <div style="font-size:smaller;">
              <a href="../contents.html">CKAN 2.2.3 documentation</a> &raquo;
              <a href="index.html"
                    accesskey="U">
                    Writing CKAN extensions
                  </a>
                   &raquo;
        </div>

        
  <div class="section" id="plugin-interfaces-reference">
<h1>Plugin interfaces reference<a class="headerlink" href="plugin-interfaces.html#plugin-interfaces-reference" title="Permalink to this headline">¶</a></h1>
<p><tt class="xref py py-mod docutils literal"><span class="pre">ckan.plugins</span></tt> contains a few core classes and functions for plugins
to use:</p>
<p class="rubric"><tt class="docutils literal"><span class="pre">ckan.plugins</span></tt></p>
<dl class="class">
<dt id="ckan.plugins.SingletonPlugin">
<em class="property">class </em><tt class="descclassname">ckan.plugins.</tt><tt class="descname">SingletonPlugin</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.SingletonPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for plugins which are singletons (ie most of them)</p>
<p>One singleton instance of this class will be created when the plugin is
loaded. Subsequent calls to the class constructor will always return the
same singleton instance.</p>
</dd></dl>

<dl class="class">
<dt id="ckan.plugins.Plugin">
<em class="property">class </em><tt class="descclassname">ckan.plugins.</tt><tt class="descname">Plugin</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.Plugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for plugins which require multiple instances.</p>
<p>Unless you need multiple instances of your plugin object you should
probably use SingletonPlugin.</p>
</dd></dl>

<dl class="function">
<dt id="ckan.plugins.implements">
<tt class="descclassname">ckan.plugins.</tt><tt class="descname">implements</tt><big>(</big><em>interface</em>, <em>namespace=None</em>, <em>inherit=False</em>, <em>service=True</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.implements" title="Permalink to this definition">¶</a></dt>
<dd><p>Can be used in the class definition of <cite>Plugin</cite> subclasses to
declare the extension points that are implemented by this
interface class.</p>
<p>If the <cite>inherits</cite> option is True, then this <cite>Plugin</cite> class
inherits from the <cite>interface</cite> class.</p>
</dd></dl>

<p class="rubric"><tt class="docutils literal"><span class="pre">ckan.plugins.interfaces</span></tt></p>
<span class="target" id="module-ckan.plugins.interfaces"></span><p>A collection of interfaces that CKAN plugins can implement to customize and
extend CKAN.</p>
<dl class="class">
<dt id="ckan.plugins.interfaces.IMiddleware">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IMiddleware</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IMiddleware" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook into Pylons middleware stack</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IMiddleware.make_middleware">
<tt class="descname">make_middleware</tt><big>(</big><em>app</em>, <em>config</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IMiddleware.make_middleware" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an app configured with this middleware</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IGenshiStreamFilter">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IGenshiStreamFilter</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGenshiStreamFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook into template rendering.
See ckan.lib.base.py:render</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IGenshiStreamFilter.filter">
<tt class="descname">filter</tt><big>(</big><em>stream</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGenshiStreamFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a filtered Genshi stream.
Called when any page is rendered.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stream</strong> &#8211; Genshi stream of the current output document</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">filtered Genshi stream</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IRoutes">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IRoutes</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IRoutes" title="Permalink to this definition">¶</a></dt>
<dd><p>Plugin into the setup of the routes map creation.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IRoutes.before_map">
<tt class="descname">before_map</tt><big>(</big><em>map</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IRoutes.before_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before the routes map is generated. <tt class="docutils literal"><span class="pre">before_map</span></tt> is before any
other mappings are created so can override all other mappings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>map</strong> &#8211; Routes map object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Modified version of the map object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IRoutes.after_map">
<tt class="descname">after_map</tt><big>(</big><em>map</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IRoutes.after_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after routes map is set up. <tt class="docutils literal"><span class="pre">after_map</span></tt> can be used to
add fall-back handlers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>map</strong> &#8211; Routes map object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Modified version of the map object</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IMapper">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IMapper</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IMapper" title="Permalink to this definition">¶</a></dt>
<dd><p>A subset of the SQLAlchemy mapper extension hooks.
See <a class="reference external" href="http://www.sqlalchemy.org/docs/05/reference/orm/interfaces.html#sqlalchemy.orm.interfaces.MapperExtension">http://www.sqlalchemy.org/docs/05/reference/orm/interfaces.html#sqlalchemy.orm.interfaces.MapperExtension</a></p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyPlugin</span><span class="p">(</span><span class="n">SingletonPlugin</span><span class="p">):</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">implements</span><span class="p">(</span><span class="n">IMapper</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">after_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">log</span><span class="p">(</span><span class="s">&quot;Updated: </span><span class="si">%r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="ckan.plugins.interfaces.IMapper.before_insert">
<tt class="descname">before_insert</tt><big>(</big><em>mapper</em>, <em>connection</em>, <em>instance</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IMapper.before_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance before that instance is INSERTed into
its table.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IMapper.before_update">
<tt class="descname">before_update</tt><big>(</big><em>mapper</em>, <em>connection</em>, <em>instance</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IMapper.before_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance before that instance is UPDATEed.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IMapper.before_delete">
<tt class="descname">before_delete</tt><big>(</big><em>mapper</em>, <em>connection</em>, <em>instance</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IMapper.before_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance before that instance is DELETEed.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IMapper.after_insert">
<tt class="descname">after_insert</tt><big>(</big><em>mapper</em>, <em>connection</em>, <em>instance</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IMapper.after_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after that instance is INSERTed.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IMapper.after_update">
<tt class="descname">after_update</tt><big>(</big><em>mapper</em>, <em>connection</em>, <em>instance</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IMapper.after_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after that instance is UPDATEed.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IMapper.after_delete">
<tt class="descname">after_delete</tt><big>(</big><em>mapper</em>, <em>connection</em>, <em>instance</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IMapper.after_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after that instance is DELETEed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.ISession">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">ISession</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.ISession" title="Permalink to this definition">¶</a></dt>
<dd><p>A subset of the SQLAlchemy session extension hooks.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.ISession.after_begin">
<tt class="descname">after_begin</tt><big>(</big><em>session</em>, <em>transaction</em>, <em>connection</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.ISession.after_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a transaction is begun on a connection</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.ISession.before_flush">
<tt class="descname">before_flush</tt><big>(</big><em>session</em>, <em>flush_context</em>, <em>instances</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.ISession.before_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute before flush process has started.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.ISession.after_flush">
<tt class="descname">after_flush</tt><big>(</big><em>session</em>, <em>flush_context</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.ISession.after_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after flush has completed, but before commit has been called.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.ISession.before_commit">
<tt class="descname">before_commit</tt><big>(</big><em>session</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.ISession.before_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute right before commit is called.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.ISession.after_commit">
<tt class="descname">after_commit</tt><big>(</big><em>session</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.ISession.after_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a commit has occured.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.ISession.after_rollback">
<tt class="descname">after_rollback</tt><big>(</big><em>session</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.ISession.after_rollback" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a rollback has occured.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IDomainObjectModification">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IDomainObjectModification</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDomainObjectModification" title="Permalink to this definition">¶</a></dt>
<dd><p>Receives notification of new, changed and deleted datesets.</p>
</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IResourceUrlChange">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IResourceUrlChange</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IResourceUrlChange" title="Permalink to this definition">¶</a></dt>
<dd><p>Receives notification of changed urls.</p>
</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IResourcePreview">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IResourcePreview</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IResourcePreview" title="Permalink to this definition">¶</a></dt>
<dd><p>Add custom data previews for resource file-types.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IResourcePreview.can_preview">
<tt class="descname">can_preview</tt><big>(</big><em>data_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IResourcePreview.can_preview" title="Permalink to this definition">¶</a></dt>
<dd><p>Return info on whether the plugin can preview the resource.</p>
<p>This can be done in two ways:</p>
<ol class="arabic">
<li><p class="first">The old way is to just return <tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
</li>
<li><p class="first">The new way is to return a dict with  three keys:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">'can_preview'</span></tt> (<tt class="docutils literal"><span class="pre">boolean</span></tt>)</dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">True</span></tt> if the extension can preview the resource.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">'fixable'</span></tt> (<tt class="docutils literal"><span class="pre">string</span></tt>)</dt>
<dd><p class="first last">A string explaining how preview for the resource could be enabled,
for example if the <tt class="docutils literal"><span class="pre">resource_proxy</span></tt> plugin was enabled.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">'quality'</span></tt> (<tt class="docutils literal"><span class="pre">int</span></tt>)</dt>
<dd><p class="first last">How good the preview is: <tt class="docutils literal"><span class="pre">1</span></tt> (poor), <tt class="docutils literal"><span class="pre">2</span></tt> (average) or
<tt class="docutils literal"><span class="pre">3</span></tt> (good). When multiple preview extensions can preview the
same resource, this is used to determine which extension will
be used.</p>
</dd>
</dl>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data_dict</strong> (<em>dictionary</em>) &#8211; the resource to be previewed and the dataset that it
belongs to.</td>
</tr>
</tbody>
</table>
<p>Make sure to check the <tt class="docutils literal"><span class="pre">on_same_domain</span></tt> value of the resource or the
url if your preview requires the resource to be on the same domain
because of the same-origin policy.  To find out how to preview
resources that are on a different domain, read <a class="reference internal" href="../data-viewer.html#resource-proxy"><em>Viewing remote resources: the resource proxy</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IResourcePreview.setup_template_variables">
<tt class="descname">setup_template_variables</tt><big>(</big><em>context</em>, <em>data_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IResourcePreview.setup_template_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Add variables to c just prior to the template being rendered.
The <tt class="docutils literal"><span class="pre">data_dict</span></tt> contains the resource and the package.</p>
<p>Change the url to a proxied domain if necessary.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IResourcePreview.preview_template">
<tt class="descname">preview_template</tt><big>(</big><em>context</em>, <em>data_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IResourcePreview.preview_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representing the location of the template to be
rendered for the read page.
The <tt class="docutils literal"><span class="pre">data_dict</span></tt> contains the resource and the package.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.ITagController">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">ITagController</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.ITagController" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook into the Tag controller. These will usually be called just before
committing or returning the respective object, i.e. all validation,
synchronization and authorization setup are complete.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.ITagController.before_view">
<tt class="descname">before_view</tt><big>(</big><em>tag_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.ITagController.before_view" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will recieve this before the tag gets displayed. The
dictionary passed will be the one that gets sent to the template.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IGroupController">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IGroupController</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupController" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook into the Group controller. These will
usually be called just before committing or returning the
respective object, i.e. all validation, synchronization
and authorization setup are complete.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupController.before_view">
<tt class="descname">before_view</tt><big>(</big><em>pkg_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupController.before_view" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will recieve this before the group gets
displayed. The dictionary passed will be the one that gets
sent to the template.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IOrganizationController">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IOrganizationController</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IOrganizationController" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook into the Organization controller. These will
usually be called just before committing or returning the
respective object, i.e. all validation, synchronization
and authorization setup are complete.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IOrganizationController.before_view">
<tt class="descname">before_view</tt><big>(</big><em>pkg_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IOrganizationController.before_view" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will recieve this before the organization gets
displayed. The dictionary passed will be the one that gets
sent to the template.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IPackageController">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IPackageController</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPackageController" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook into the package controller.
(see IGroupController)</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IPackageController.after_create">
<tt class="descname">after_create</tt><big>(</big><em>context</em>, <em>pkg_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPackageController.after_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will receive the validated data dict after the package
has been created (Note that the create method will return a package
domain object, which may not include all fields). Also the newly
created package id will be added to the dict.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IPackageController.after_update">
<tt class="descname">after_update</tt><big>(</big><em>context</em>, <em>pkg_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPackageController.after_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will receive the validated data dict after the package
has been updated (Note that the edit method will return a package
domain object, which may not include all fields).</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IPackageController.after_delete">
<tt class="descname">after_delete</tt><big>(</big><em>context</em>, <em>pkg_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPackageController.after_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will receive the data dict (tipically containing
just the package id) after the package has been deleted.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IPackageController.after_show">
<tt class="descname">after_show</tt><big>(</big><em>context</em>, <em>pkg_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPackageController.after_show" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will receive the validated data dict after the package
is ready for display (Note that the read method will return a
package domain object, which may not include all fields).</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IPackageController.before_search">
<tt class="descname">before_search</tt><big>(</big><em>search_params</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPackageController.before_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will receive a dictionary with the query parameters,
and should return a modified (or not) version of it.</p>
<p>search_params will include an <cite>extras</cite> dictionary with all values
from fields starting with <cite>ext_</cite>, so extensions can receive user
input from specific fields.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IPackageController.after_search">
<tt class="descname">after_search</tt><big>(</big><em>search_results</em>, <em>search_params</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPackageController.after_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will receive the search results, as well as the search
parameters, and should return a modified (or not) object with the
same structure:</p>
<blockquote>
<div>{&#8216;count&#8217;: &#8216;&#8217;, &#8216;results&#8217;: &#8216;&#8217;, &#8216;facets&#8217;: &#8216;&#8217;}</div></blockquote>
<p>Note that count and facets may need to be adjusted if the extension
changed the results for some reason.</p>
<p>search_params will include an <cite>extras</cite> dictionary with all values
from fields starting with <cite>ext_</cite>, so extensions can receive user
input from specific fields.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IPackageController.before_index">
<tt class="descname">before_index</tt><big>(</big><em>pkg_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPackageController.before_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will receive what will be given to the solr for
indexing. This is essentially a flattened dict (except for
multli-valued fields such as tags) of all the terms sent to
the indexer. The extension can modify this by returning an
altered version.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IPackageController.before_view">
<tt class="descname">before_view</tt><big>(</big><em>pkg_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPackageController.before_view" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will recieve this before the dataset gets
displayed. The dictionary passed will be the one that gets
sent to the template.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IResourceController">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IResourceController</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IResourceController" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook into the resource controller.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IResourceController.before_show">
<tt class="descname">before_show</tt><big>(</big><em>resource_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IResourceController.before_show" title="Permalink to this definition">¶</a></dt>
<dd><p>Extensions will receive the validated data dict before the resource
is ready for display.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IPluginObserver">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IPluginObserver</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPluginObserver" title="Permalink to this definition">¶</a></dt>
<dd><p>Plugin to the plugin loading mechanism</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IPluginObserver.before_load">
<tt class="descname">before_load</tt><big>(</big><em>plugin</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPluginObserver.before_load" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before a plugin is loaded
This method is passed the plugin class.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IPluginObserver.after_load">
<tt class="descname">after_load</tt><big>(</big><em>service</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPluginObserver.after_load" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after a plugin has been loaded.
This method is passed the instantiated service object.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IPluginObserver.before_unload">
<tt class="descname">before_unload</tt><big>(</big><em>plugin</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPluginObserver.before_unload" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before a plugin is loaded
This method is passed the plugin class.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IPluginObserver.after_unload">
<tt class="descname">after_unload</tt><big>(</big><em>service</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IPluginObserver.after_unload" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after a plugin has been unloaded.
This method is passed the instantiated service object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IConfigurable">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IConfigurable</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IConfigurable" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass configuration to plugins and extensions</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IConfigurable.configure">
<tt class="descname">configure</tt><big>(</big><em>config</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IConfigurable.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by load_environment</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IConfigurer">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IConfigurer</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IConfigurer" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure CKAN (pylons) environment via the <tt class="docutils literal"><span class="pre">pylons.config</span></tt> object</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IConfigurer.update_config">
<tt class="descname">update_config</tt><big>(</big><em>config</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IConfigurer.update_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by load_environment at earliest point when config is
available to plugins. The config should be updated in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config</strong> &#8211; <tt class="docutils literal"><span class="pre">pylons.config</span></tt> object</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IActions">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IActions</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IActions" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow adding of actions to the logic layer.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IActions.get_actions">
<tt class="descname">get_actions</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IActions.get_actions" title="Permalink to this definition">¶</a></dt>
<dd><p>Should return a dict, the keys being the name of the logic
function and the values being the functions themselves.</p>
<p>By decorating a function with the <cite>ckan.logic.side_effect_free</cite>
decorator, the associated action will be made available by a GET
request (as well as the usual POST request) through the action API.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IAuthFunctions">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IAuthFunctions</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IAuthFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Override CKAN&#8217;s authorization functions, or add new auth functions.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IAuthFunctions.get_auth_functions">
<tt class="descname">get_auth_functions</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IAuthFunctions.get_auth_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the authorization functions provided by this plugin.</p>
<p>Return a dictionary mapping authorization function names (strings) to
functions. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;user_create&#39;</span><span class="p">:</span> <span class="n">my_custom_user_create_function</span><span class="p">,</span>
 <span class="s">&#39;group_create&#39;</span><span class="p">:</span> <span class="n">my_custom_group_create</span><span class="p">}</span>
</pre></div>
</div>
<p>When a user tries to carry out an action via the CKAN API or web
interface and CKAN or a CKAN plugin calls
<tt class="docutils literal"><span class="pre">check_access('some_action')</span></tt> as a result, an authorization function
named <tt class="docutils literal"><span class="pre">'some_action'</span></tt> will be searched for in the authorization
functions registered by plugins and in CKAN&#8217;s core authorization
functions (found in <tt class="docutils literal"><span class="pre">ckan/logic/auth/</span></tt>).</p>
<p>For example when a user tries to create a package, a
<tt class="docutils literal"><span class="pre">'package_create'</span></tt> authorization function is searched for.</p>
<p>If an extension registers an authorization function with the same name
as one of CKAN&#8217;s default authorization functions (as with
<tt class="docutils literal"><span class="pre">'user_create'</span></tt> and <tt class="docutils literal"><span class="pre">'group_create'</span></tt> above), the extension&#8217;s
function will override the default one.</p>
<p>Each authorization function should take two parameters <tt class="docutils literal"><span class="pre">context</span></tt> and
<tt class="docutils literal"><span class="pre">data_dict</span></tt>, and should return a dictionary <tt class="docutils literal"><span class="pre">{'success':</span> <span class="pre">True}</span></tt> to
authorize the action or <tt class="docutils literal"><span class="pre">{'success':</span> <span class="pre">False}</span></tt> to deny it, for
example:</p>
<div class="highlight-python"><div class="highlight"><pre>def user_create(context, data_dict=None):
    if (some condition):
        return {&#39;success&#39;: True}
    else:
        return {&#39;success&#39;: False, &#39;msg&#39;: &#39;Not allowed to register&#39;}
</pre></div>
</div>
<p>The context object will contain a <tt class="docutils literal"><span class="pre">model</span></tt> that can be used to query
the database, a <tt class="docutils literal"><span class="pre">user</span></tt> containing the name of the user doing the
request (or their IP if it is an anonymous web request) and an
<tt class="docutils literal"><span class="pre">auth_user_obj</span></tt> containing the actual model.User object (or None if
it is an anonymous request).</p>
<p>See <tt class="docutils literal"><span class="pre">ckan/logic/auth/</span></tt> for more examples.</p>
<p>Note that by default, all auth functions provided by extensions are assumed
to require a validated user or API key, otherwise a
<tt class="xref py py-class docutils literal"><span class="pre">ckan.logic.NotAuthorized</span></tt>: exception will be raised. This check
will be performed <em>before</em> calling the actual auth function. If you want
to allow anonymous access to one of your actions, its auth function must
be decorated with the <tt class="docutils literal"><span class="pre">auth_allow_anonymous_access</span></tt> decorator, available
on the plugins toolkit.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>import ckan.plugins as p

@p.toolkit.auth_allow_anonymous_access
def my_search_action(context, data_dict):
    # Note that you can still return {&#39;success&#39;: False} if for some
    # reason access is denied.

def my_create_action(context, data_dict):
    # Unless there is a logged in user or a valid API key provided
    # NotAuthorized will be raised before reaching this function.
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.ITemplateHelpers">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">ITemplateHelpers</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.ITemplateHelpers" title="Permalink to this definition">¶</a></dt>
<dd><p>Add custom template helper functions.</p>
<p>By implementing this plugin interface plugins can provide their own
template helper functions, which custom templates can then access via the
<tt class="docutils literal"><span class="pre">h</span></tt> variable.</p>
<p>See <tt class="docutils literal"><span class="pre">ckanext/example_itemplatehelpers</span></tt> for an example plugin.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.ITemplateHelpers.get_helpers">
<tt class="descname">get_helpers</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.ITemplateHelpers.get_helpers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dict mapping names to helper functions.</p>
<p>The keys of the dict should be the names with which the helper
functions will be made available to templates, and the values should be
the functions themselves. For example, a dict like:
<tt class="docutils literal"><span class="pre">{'example_helper':</span> <span class="pre">example_helper}</span></tt> allows templates to access the
<tt class="docutils literal"><span class="pre">example_helper</span></tt> function via <tt class="docutils literal"><span class="pre">h.example_helper()</span></tt>.</p>
<p>Function names should start with the name of the extension providing
the function, to prevent name clashes between extensions.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IDatasetForm">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IDatasetForm</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm" title="Permalink to this definition">¶</a></dt>
<dd><p>Customize CKAN&#8217;s dataset (package) schemas and forms.</p>
<p>By implementing this interface plugins can customise CKAN&#8217;s dataset schema,
for example to add new custom fields to datasets.</p>
<p>Multiple IDatasetForm plugins can be used at once, each plugin associating
itself with different package types using the <tt class="docutils literal"><span class="pre">package_types()</span></tt> and
<tt class="docutils literal"><span class="pre">is_fallback()</span></tt> methods below, and then providing different schemas and
templates for different types of dataset.  When a package controller action
is invoked, the <tt class="docutils literal"><span class="pre">type</span></tt> field of the package will determine which
IDatasetForm plugin (if any) gets delegated to.</p>
<p>When implementing IDatasetForm, you can inherit from
<tt class="docutils literal"><span class="pre">ckan.plugins.toolkit.DefaultDatasetForm</span></tt>, which provides default
implementations for each of the methods defined in this interface.</p>
<p>See <tt class="docutils literal"><span class="pre">ckanext/example_idatasetform</span></tt> for an example plugin.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.package_types">
<tt class="descname">package_types</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.package_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterable of package types that this plugin handles.</p>
<p>If a request involving a package of one of the returned types is made,
then this plugin instance will be delegated to.</p>
<p>There cannot be two IDatasetForm plugins that return the same package
type, if this happens then CKAN will raise an exception at startup.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">iterable of strings</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.is_fallback">
<tt class="descname">is_fallback</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.is_fallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if this plugin is the fallback plugin.</p>
<p>When no IDatasetForm plugin&#8217;s <tt class="docutils literal"><span class="pre">package_types()</span></tt> match the <tt class="docutils literal"><span class="pre">type</span></tt> of
the package being processed, the fallback plugin is delegated to
instead.</p>
<p>There cannot be more than one IDatasetForm plugin whose
<tt class="docutils literal"><span class="pre">is_fallback()</span></tt> method returns <tt class="docutils literal"><span class="pre">True</span></tt>, if this happens CKAN will
raise an exception at startup.</p>
<p>If no IDatasetForm plugin&#8217;s <tt class="docutils literal"><span class="pre">is_fallback()</span></tt> method returns <tt class="docutils literal"><span class="pre">True</span></tt>,
CKAN will use <tt class="docutils literal"><span class="pre">DefaultDatasetForm</span></tt> as the fallback.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.create_package_schema">
<tt class="descname">create_package_schema</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.create_package_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the schema for validating new dataset dicts.</p>
<p>CKAN will use the returned schema to validate and convert data coming
from users (via the dataset form or API) when creating new datasets,
before entering that data into the database.</p>
<p>If it inherits from <tt class="docutils literal"><span class="pre">ckan.plugins.toolkit.DefaultDatasetForm</span></tt>, a
plugin can call <tt class="docutils literal"><span class="pre">DefaultDatasetForm</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">create_package_schema()</span></tt>
method to get the default schema and then modify and return it.</p>
<p>CKAN&#8217;s <tt class="docutils literal"><span class="pre">convert_to_tags()</span></tt> or <tt class="docutils literal"><span class="pre">convert_to_extras()</span></tt> functions can
be used to convert custom fields into dataset tags or extras for
storing in the database.</p>
<p>See <tt class="docutils literal"><span class="pre">ckanext/example_idatasetform</span></tt> for examples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a dictionary mapping dataset dict keys to lists of validator
and converter functions to be applied to those keys</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dictionary</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.update_package_schema">
<tt class="descname">update_package_schema</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.update_package_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the schema for validating updated dataset dicts.</p>
<p>CKAN will use the returned schema to validate and convert data coming
from users (via the dataset form or API) when updating datasets, before
entering that data into the database.</p>
<p>If it inherits from <tt class="docutils literal"><span class="pre">ckan.plugins.toolkit.DefaultDatasetForm</span></tt>, a
plugin can call <tt class="docutils literal"><span class="pre">DefaultDatasetForm</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">update_package_schema()</span></tt>
method to get the default schema and then modify and return it.</p>
<p>CKAN&#8217;s <tt class="docutils literal"><span class="pre">convert_to_tags()</span></tt> or <tt class="docutils literal"><span class="pre">convert_to_extras()</span></tt> functions can
be used to convert custom fields into dataset tags or extras for
storing in the database.</p>
<p>See <tt class="docutils literal"><span class="pre">ckanext/example_idatasetform</span></tt> for examples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a dictionary mapping dataset dict keys to lists of validator
and converter functions to be applied to those keys</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dictionary</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.show_package_schema">
<tt class="descname">show_package_schema</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.show_package_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a schema to validate datasets before they&#8217;re shown to the user.</p>
<p>CKAN will use the returned schema to validate and convert data coming
from the database before it is returned to the user via the API or
passed to a template for rendering.</p>
<p>If it inherits from <tt class="docutils literal"><span class="pre">ckan.plugins.toolkit.DefaultDatasetForm</span></tt>, a
plugin can call <tt class="docutils literal"><span class="pre">DefaultDatasetForm</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">show_package_schema()</span></tt>
method to get the default schema and then modify and return it.</p>
<p>If you have used <tt class="docutils literal"><span class="pre">convert_to_tags()</span></tt> or <tt class="docutils literal"><span class="pre">convert_to_extras()</span></tt> in
your <tt class="docutils literal"><span class="pre">create_package_schema()</span></tt> and <tt class="docutils literal"><span class="pre">update_package_schema()</span></tt> then
you should use <tt class="docutils literal"><span class="pre">convert_from_tags()</span></tt> or <tt class="docutils literal"><span class="pre">convert_from_extras()</span></tt> in
your <tt class="docutils literal"><span class="pre">show_package_schema()</span></tt> to convert the tags or extras in the
database back into your custom dataset fields.</p>
<p>See <tt class="docutils literal"><span class="pre">ckanext/example_idatasetform</span></tt> for examples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a dictionary mapping dataset dict keys to lists of validator
and converter functions to be applied to those keys</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dictionary</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.setup_template_variables">
<tt class="descname">setup_template_variables</tt><big>(</big><em>context</em>, <em>data_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.setup_template_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Add variables to the template context for use in templates.</p>
<p>This function is called before a dataset template is rendered. If you
have custom dataset templates that require some additional variables,
you can add them to the template context <tt class="docutils literal"><span class="pre">ckan.plugins.toolkit.c</span></tt>
here and they will be available in your templates. See
<tt class="docutils literal"><span class="pre">ckanext/example_idatasetform</span></tt> for an example.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.new_template">
<tt class="descname">new_template</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.new_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the template for the new dataset page.</p>
<p>The path should be relative to the plugin&#8217;s templates dir, e.g.
<tt class="docutils literal"><span class="pre">'package/new.html'</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.read_template">
<tt class="descname">read_template</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.read_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the template for the dataset read page.</p>
<p>The path should be relative to the plugin&#8217;s templates dir, e.g.
<tt class="docutils literal"><span class="pre">'package/read.html'</span></tt>.</p>
<p>If the user requests the dataset in a format other than HTML
(CKAN supports returning datasets in RDF or N3 format by appending .rdf
or .n3 to the dataset read URL, see <a class="reference internal" href="../linked-data-and-rdf.html"><em>Linked Data and RDF</em></a>) then
CKAN will try to render
a template file with the same path as returned by this function,
but a different filename extension, e.g. <tt class="docutils literal"><span class="pre">'package/read.rdf'</span></tt>.
If your extension doesn&#8217;t have this RDF version of the template
file, the user will get a 404 error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.edit_template">
<tt class="descname">edit_template</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.edit_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the template for the dataset edit page.</p>
<p>The path should be relative to the plugin&#8217;s templates dir, e.g.
<tt class="docutils literal"><span class="pre">'package/edit.html'</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.search_template">
<tt class="descname">search_template</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.search_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the template for use in the dataset search page.</p>
<p>This template is used to render each dataset that is listed in the
search results on the dataset search page.</p>
<p>The path should be relative to the plugin&#8217;s templates dir, e.g.
<tt class="docutils literal"><span class="pre">'package/search.html'</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.history_template">
<tt class="descname">history_template</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.history_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the template for the dataset history page.</p>
<p>The path should be relative to the plugin&#8217;s templates dir, e.g.
<tt class="docutils literal"><span class="pre">'package/history.html'</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IDatasetForm.package_form">
<tt class="descname">package_form</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IDatasetForm.package_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the template for the dataset form.</p>
<p>The path should be relative to the plugin&#8217;s templates dir, e.g.
<tt class="docutils literal"><span class="pre">'package/form.html'</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IGroupForm">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IGroupForm</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows customisation of the group controller as a plugin.</p>
<p>The behaviour of the plugin is determined by 5 method hooks:</p>
<blockquote>
<div><ul class="simple">
<li>package_form(self)</li>
<li>form_to_db_schema(self)</li>
<li>db_to_form_schema(self)</li>
<li>check_data_dict(self, data_dict)</li>
<li>setup_template_variables(self, context, data_dict)</li>
</ul>
</div></blockquote>
<p>Furthermore, there can be many implementations of this plugin registered
at once.  With each instance associating itself with 0 or more package
type strings.  When a package controller action is invoked, the package
type determines which of the registered plugins to delegate to.  Each
implementation must implement two methods which are used to determine the
package-type -&gt; plugin mapping:</p>
<blockquote>
<div><ul class="simple">
<li>is_fallback(self)</li>
<li>package_types(self)</li>
</ul>
</div></blockquote>
<p>Implementations might want to consider mixing in
ckan.lib.plugins.DefaultGroupForm which provides
default behaviours for the 5 method hooks.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.is_fallback">
<tt class="descname">is_fallback</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.is_fallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff this provides the fallback behaviour, when no other
plugin instance matches a package&#8217;s type.</p>
<p>There must be exactly one fallback controller defined, any attempt to
register more than one will throw an exception at startup.  If there&#8217;s
no fallback registered at startup the
ckan.lib.plugins.DefaultGroupForm used as the fallback.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.group_types">
<tt class="descname">group_types</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.group_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterable of group type strings.</p>
<p>If a request involving a package of one of those types is made, then
this plugin instance will be delegated to.</p>
<p>There must only be one plugin registered to each group type.  Any
attempts to register more than one plugin instance to a given group
type will raise an exception at startup.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.new_template">
<tt class="descname">new_template</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.new_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representing the location of the template to be
rendered for the &#8216;new&#8217; page. Uses the default_group_type configuration
option to determine which plugin to use the template from.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.index_template">
<tt class="descname">index_template</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.index_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representing the location of the template to be
rendered for the index page. Uses the default_group_type configuration
option to determine which plugin to use the template from.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.read_template">
<tt class="descname">read_template</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.read_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representing the location of the template to be
rendered for the read page</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.history_template">
<tt class="descname">history_template</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.history_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representing the location of the template to be
rendered for the history page</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.edit_template">
<tt class="descname">edit_template</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.edit_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representing the location of the template to be
rendered for the edit page</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.package_form">
<tt class="descname">package_form</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.package_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representing the location of the template to be
rendered.  e.g. &#8220;group/new_group_form.html&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.form_to_db_schema">
<tt class="descname">form_to_db_schema</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.form_to_db_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the schema for mapping group data from a form to a format
suitable for the database.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.db_to_form_schema">
<tt class="descname">db_to_form_schema</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.db_to_form_schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the schema for mapping group data from the database into a
format suitable for the form (optional)</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.check_data_dict">
<tt class="descname">check_data_dict</tt><big>(</big><em>data_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.check_data_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the return data is correct.</p>
<p>raise a DataError if not.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IGroupForm.setup_template_variables">
<tt class="descname">setup_template_variables</tt><big>(</big><em>context</em>, <em>data_dict</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IGroupForm.setup_template_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Add variables to c just prior to the template being rendered.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IFacets">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IFacets</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IFacets" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows specify which facets are displayed and also the names used.</p>
<p>facet_dicts are in the form {&#8216;facet_name&#8217;: &#8216;display name&#8217;, ...}
to allow translatable display names use _(...)
eg {&#8216;facet_name&#8217;: _(&#8216;display name&#8217;), ...} and ensure that this is
created each time the function is called.</p>
<p>The dict supplied is actually an ordered dict.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IFacets.dataset_facets">
<tt class="descname">dataset_facets</tt><big>(</big><em>facets_dict</em>, <em>package_type</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IFacets.dataset_facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the facets_dict and return it.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IFacets.group_facets">
<tt class="descname">group_facets</tt><big>(</big><em>facets_dict</em>, <em>group_type</em>, <em>package_type</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IFacets.group_facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the facets_dict and return it.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IFacets.organization_facets">
<tt class="descname">organization_facets</tt><big>(</big><em>facets_dict</em>, <em>organization_type</em>, <em>package_type</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IFacets.organization_facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the facets_dict and return it.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ckan.plugins.interfaces.IAuthenticator">
<em class="property">class </em><tt class="descclassname">ckan.plugins.interfaces.</tt><tt class="descname">IAuthenticator</tt><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IAuthenticator" title="Permalink to this definition">¶</a></dt>
<dd><p>EXPERIMENTAL</p>
<p>Allows custom authentication methods to be integrated into CKAN.
Currently it is experimental and the interface may change.</p>
<dl class="method">
<dt id="ckan.plugins.interfaces.IAuthenticator.identify">
<tt class="descname">identify</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IAuthenticator.identify" title="Permalink to this definition">¶</a></dt>
<dd><p>called to identify the user.</p>
<p>If the user is identfied then it should set
c.user: The id of the user
c.userobj: The actual user object (this may be removed as a
requirement in a later release so that access to the model is not
required)</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IAuthenticator.login">
<tt class="descname">login</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IAuthenticator.login" title="Permalink to this definition">¶</a></dt>
<dd><p>called at login.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IAuthenticator.logout">
<tt class="descname">logout</tt><big>(</big><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IAuthenticator.logout" title="Permalink to this definition">¶</a></dt>
<dd><p>called at logout.</p>
</dd></dl>

<dl class="method">
<dt id="ckan.plugins.interfaces.IAuthenticator.abort">
<tt class="descname">abort</tt><big>(</big><em>status_code</em>, <em>detail</em>, <em>headers</em>, <em>comment</em><big>)</big><a class="headerlink" href="plugin-interfaces.html#ckan.plugins.interfaces.IAuthenticator.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>called on abort.  This allows aborts due to authorization issues
to be overriden</p>
</dd></dl>

</dd></dl>

</div>



        
        <div style="font-size:smaller;">
          <hr/>
          
            
          
            
          
            
              <div class="pull-right">
                <a href="plugins-toolkit.html"
                  title="Plugins toolkit reference" accesskey="N">
                    
                      
                    
                    Plugins toolkit reference→
                </a>
              </div>
            
          
            
              <div >
                <a href="best-practices.html"
                  title="Best practices for writing extensions" accesskey="P">
                    
                      
                    
                    ← Best practices for writing extensions
                </a>
              </div>
            
          
          <div style="clear:both;"></div>
        </div>

      </div>
    </div>
  </div> <!-- / row -->
</div>

<footer>
  <div class="inner">
    <div class="container-fluid">
      <p>An <a href="http://okfn.org">Open Knowledge Foundation</a> project.</p>

<p class="copyright">
  &copy; 2009-2013, <a href="http://okfn.org/">Open Knowledge Foundation</a>.
    Licensed under <a
    href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons
    Attribution ShareAlike (Unported) v3.0 License</a>.<br />
    <img src="http://i.creativecommons.org/l/by-sa/3.0/80x15.png" alt="CC License Logo" />
    <a href="http://opendefinition.org/"><img src="http://assets.okfn.org/images/ok_buttons/oc_80x15_blue.png" border="0"
      alt="{{ _('Open Content') }}" /></a>
  <br/>
</p>

<p>
<a href="https://github.com/ckan/ckan">Source</a>
&mdash;
<a href="https://github.com/ckan/ckan/issues">Issues</a>
&mdash;
<a href="http://lists.okfn.org/mailman/listinfo/ckan-dev">Mailing List</a>
&mdash;
<a href="http://twitter.com/CKANProject">Twitter @CKANProject</a>
</p>

<p>
Related Projects:
<a href="http://thedatahub.org/">The DataHub</a>
&mdash;
<a href="http://datacatalogs.org">DataCatalogs.org</a>
&mdash;
<a href="http://openspending.org">OpenSpending.org</a>
&mdash;
<a href="http://opendatahandbook.org">Open Data Handbook</a>
</p>

    </div>
  </div>
</footer>



  </body>
</html>